/*
 * Copyright 2018 Royal Bank of Scotland
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';Object.defineProperty(exports, "__esModule", { value: true });

var _ServiceProxy = require('./ServiceProxy');var _ServiceProxy2 = _interopRequireDefault(_ServiceProxy);
var _UrlParse = require('./UrlParse');var _UrlParse2 = _interopRequireDefault(_UrlParse);
var _request = require('request');var _request2 = _interopRequireDefault(_request);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}

/**
                                                                                                                                                                                                                                                                                                                                       * This class creates a first-class JS object with methods that proxy to a given service end-point
                                                                                                                                                                                                                                                                                                                                       */var
DynamicProxy =
/**
                *
                * @param config - an object with the following fields
                *  'url' - required - the url that this proxy will connect to
                *  'credentials' - optional - payload for the authentication service used by the server - default is no auth expected
                *  'console' - optional - the console implementation (according to the Javascript spec https://developer.mozilla.org/en-US/docs/Web/API/console)
                *
                *  example: {
                *    url: 'https://localhost:8080/api',
                *    credentials: {
                *      username: 'foo',
                *      password: 'bar'
                *    }
                *  }
                * @param serviceName - the name of the service being bound to
                * @param onOpen - callback when this proxy has connected to the service
                * @param onClose - callback when this proxy has disconnected from the service
                * @param onError - callback when this proxy has failed to connect
                * @param options - transport level options. see SockJS options: https://github.com/sockjs/sockjs-client
                */
function DynamicProxy(config, serviceName, onOpen, onClose, onError, options) {_classCallCheck(this, DynamicProxy);
  var that = this;
  if (config === null) {
    throw "config must not be null and must have a url field";
  }

  if (!config.url) {
    throw "missing url property in config";
  }

  if (!config.console) {
    config.console = console;
  }

  if (typeof options === 'undefined') {
    options = {};
  }

  if (typeof options.strictSSL === 'undefined') {
    options.strictSSL = true;
  }

  if (!options.strictSSL) {
    if (typeof process !== 'undefined' && typeof process.env !== 'undefined') {
      // NOTE: rather nasty - to be used only in local dev for self-signed certificates
      process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
    }
  }

  config = Object.assign({}, config); // clone so that we can then get rid of the credentials once logged in
  var serviceEndPoint = config.url + serviceName + "/braid";
  var proxy = new _ServiceProxy2.default(serviceEndPoint, internalOnOpen, onClose, function (err) {return failed('to open service proxy for ' + serviceName, err);}, options);

  // --- PRIVATE FUNCTIONS ---

  function internalOnOpen() {
    Promise.resolve().
    then(function () {
      if (config.credentials) {
        return proxy.login(config.credentials);
      }
      return null;
    }).
    then(function () {
      clearCredentials();
      retrieveMetadataAndBind();
    }, function (err) {
      failed("failed to open", err);
    });
  }

  function retrieveMetadataAndBind() {
    try {
      var url = getMetadataEndpoint(config, serviceName);

      (0, _request2.default)({
        method: "get",
        uri: url,
        strictSSL: options.strictSSL,
        rejectUnauthorized: !options.strictSSL,
        headers: {
          "Content-Type": "application/json" } },

      function (err, resp, body) {
        if (err) {
          failed(err);
        } else
        if (resp.statusCode !== 200) {
          failed(resp.statusMessage);
        } else if (body) {
          bindMetadata(body);
        } else {
          var message = "no error nor response!";
          config.console.error(message, url);
          failed(message);
        }
      });
    } catch (err) {
      failed(err);
    }
  }

  function bindMetadata(body) {
    try {
      var metadata = JSON.parse(body);
      for (var idx = 0; idx < metadata.length; ++idx) {
        bind(metadata[idx]);
      }
      if (onOpen) {
        onOpen();
      }
    } catch (error) {
      failed(error);
    }
  }

  function bind(item) {
    var name = item.name;
    if (!that.hasOwnProperty(name)) {
      var _fn = function _fn() {for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
        return invoke.apply(undefined, [name].concat(args));
      };
      _fn.__metadata = []; // to populate with metadata on signature and documentation
      _fn.docs = function () {config.console.log(getDocs(_fn));};
      _fn.getDocs = function () {return getDocs(_fn);};
      that[name] = _fn;
    }
    // append the metadata for the method. N.B. methods can have overloads, hence the use of an array.
    var fn = that[name];
    fn.__metadata.push(item);
    return that[name];
  }

  function invoke(methodName) {for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {args[_key2 - 1] = arguments[_key2];}
    return proxy[methodName].apply(proxy, args);
  }

  function failed(reason, e) {
    if (onError) {
      onError({ reason: reason, error: e });
    } else {
      config.console.error(reason, e);
    }
  }


  function getMetadataEndpoint(config, serviceName) {
    var parsed = parseURL(config.url);
    var result = parsed.protocol + "//" + parsed.hostname + ":" + parsed.port + "/api/" + serviceName;
    return result;
  }

  function parseURL(url) {
    return new _UrlParse2.default(url);
  }

  function clearCredentials() {
    config.credentials = null;
  }

  /**
     * prints documentation of a function's metadata
     *
     * @param fn - the respective function
     */
  function getDocs(fn) {
    var msg = "API documentation\n" +
    "-----------------\n";
    for (var idx in fn.__metadata) {
      var methodDefinition = fn.__metadata[idx];
      if (!methodDefinition.returnType) {
        methodDefinition.returnType = 'unknown';
      }
      var apifn = "* " + methodDefinition.name + '(' + generateParamList(methodDefinition) + ') => ' + methodDefinition.returnType + '\n';
      apifn += methodDefinition.description + '\n';
      apifn += generateParamDocs(methodDefinition);
      msg += apifn + '\n\n';
    }
    return msg;
  }

  function generateParamList(methodDefinition) {
    return Object.keys(methodDefinition.parameters).join(', ');
  }

  function generateParamDocs(methodDefinition) {
    return Object.keys(methodDefinition.parameters).
    map(function (p) {
      return '  @param ' + p + ' - ' + methodDefinition.parameters[p];
    }).join('\n');
  }
  // --- PUBLIC FUNCTIONS ---

  // --- INITIALISATION ---
};exports.default = DynamicProxy;